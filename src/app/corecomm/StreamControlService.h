/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef StreamControlService_H
#define StreamControlService_H

#include <TProcessor.h>
#include "CoreServices_types.h"

namespace com { namespace kaisquare { namespace core { namespace thrift {

class StreamControlServiceIf {
 public:
  virtual ~StreamControlServiceIf() {}
  virtual void beginStreamSession(std::vector<std::string> & _return, const std::string& sessionId, const int64_t ttl, const std::string& type, const std::vector<std::string> & allowedClientIpAddresses, const std::string& deviceId, const std::string& channelId, const std::string& startTimestamp, const std::string& endTimeStamp) = 0;
  virtual bool keepStreamSessionAlive(const std::string& sessionId, const int64_t ttl, const std::vector<std::string> & allowedClientIpAddresses) = 0;
  virtual bool endStreamSession(const std::string& sessionId) = 0;
};

class StreamControlServiceIfFactory {
 public:
  typedef StreamControlServiceIf Handler;

  virtual ~StreamControlServiceIfFactory() {}

  virtual StreamControlServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(StreamControlServiceIf* /* handler */) = 0;
};

class StreamControlServiceIfSingletonFactory : virtual public StreamControlServiceIfFactory {
 public:
  StreamControlServiceIfSingletonFactory(const boost::shared_ptr<StreamControlServiceIf>& iface) : iface_(iface) {}
  virtual ~StreamControlServiceIfSingletonFactory() {}

  virtual StreamControlServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(StreamControlServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<StreamControlServiceIf> iface_;
};

class StreamControlServiceNull : virtual public StreamControlServiceIf {
 public:
  virtual ~StreamControlServiceNull() {}
  void beginStreamSession(std::vector<std::string> & /* _return */, const std::string& /* sessionId */, const int64_t /* ttl */, const std::string& /* type */, const std::vector<std::string> & /* allowedClientIpAddresses */, const std::string& /* deviceId */, const std::string& /* channelId */, const std::string& /* startTimestamp */, const std::string& /* endTimeStamp */) {
    return;
  }
  bool keepStreamSessionAlive(const std::string& /* sessionId */, const int64_t /* ttl */, const std::vector<std::string> & /* allowedClientIpAddresses */) {
    bool _return = false;
    return _return;
  }
  bool endStreamSession(const std::string& /* sessionId */) {
    bool _return = false;
    return _return;
  }
};

typedef struct _StreamControlService_beginStreamSession_args__isset {
  _StreamControlService_beginStreamSession_args__isset() : sessionId(false), ttl(false), type(false), allowedClientIpAddresses(false), deviceId(false), channelId(false), startTimestamp(false), endTimeStamp(false) {}
  bool sessionId;
  bool ttl;
  bool type;
  bool allowedClientIpAddresses;
  bool deviceId;
  bool channelId;
  bool startTimestamp;
  bool endTimeStamp;
} _StreamControlService_beginStreamSession_args__isset;

class StreamControlService_beginStreamSession_args {
 public:

  StreamControlService_beginStreamSession_args() : sessionId(""), ttl(0), type(""), deviceId(""), channelId(""), startTimestamp(""), endTimeStamp("") {
  }

  virtual ~StreamControlService_beginStreamSession_args() throw() {}

  std::string sessionId;
  int64_t ttl;
  std::string type;
  std::vector<std::string>  allowedClientIpAddresses;
  std::string deviceId;
  std::string channelId;
  std::string startTimestamp;
  std::string endTimeStamp;

  _StreamControlService_beginStreamSession_args__isset __isset;

  void __set_sessionId(const std::string& val) {
    sessionId = val;
  }

  void __set_ttl(const int64_t val) {
    ttl = val;
  }

  void __set_type(const std::string& val) {
    type = val;
  }

  void __set_allowedClientIpAddresses(const std::vector<std::string> & val) {
    allowedClientIpAddresses = val;
  }

  void __set_deviceId(const std::string& val) {
    deviceId = val;
  }

  void __set_channelId(const std::string& val) {
    channelId = val;
  }

  void __set_startTimestamp(const std::string& val) {
    startTimestamp = val;
  }

  void __set_endTimeStamp(const std::string& val) {
    endTimeStamp = val;
  }

  bool operator == (const StreamControlService_beginStreamSession_args & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(ttl == rhs.ttl))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(allowedClientIpAddresses == rhs.allowedClientIpAddresses))
      return false;
    if (!(deviceId == rhs.deviceId))
      return false;
    if (!(channelId == rhs.channelId))
      return false;
    if (!(startTimestamp == rhs.startTimestamp))
      return false;
    if (!(endTimeStamp == rhs.endTimeStamp))
      return false;
    return true;
  }
  bool operator != (const StreamControlService_beginStreamSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamControlService_beginStreamSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StreamControlService_beginStreamSession_pargs {
 public:


  virtual ~StreamControlService_beginStreamSession_pargs() throw() {}

  const std::string* sessionId;
  const int64_t* ttl;
  const std::string* type;
  const std::vector<std::string> * allowedClientIpAddresses;
  const std::string* deviceId;
  const std::string* channelId;
  const std::string* startTimestamp;
  const std::string* endTimeStamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StreamControlService_beginStreamSession_result__isset {
  _StreamControlService_beginStreamSession_result__isset() : success(false) {}
  bool success;
} _StreamControlService_beginStreamSession_result__isset;

class StreamControlService_beginStreamSession_result {
 public:

  StreamControlService_beginStreamSession_result() {
  }

  virtual ~StreamControlService_beginStreamSession_result() throw() {}

  std::vector<std::string>  success;

  _StreamControlService_beginStreamSession_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const StreamControlService_beginStreamSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StreamControlService_beginStreamSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamControlService_beginStreamSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StreamControlService_beginStreamSession_presult__isset {
  _StreamControlService_beginStreamSession_presult__isset() : success(false) {}
  bool success;
} _StreamControlService_beginStreamSession_presult__isset;

class StreamControlService_beginStreamSession_presult {
 public:


  virtual ~StreamControlService_beginStreamSession_presult() throw() {}

  std::vector<std::string> * success;

  _StreamControlService_beginStreamSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StreamControlService_keepStreamSessionAlive_args__isset {
  _StreamControlService_keepStreamSessionAlive_args__isset() : sessionId(false), ttl(false), allowedClientIpAddresses(false) {}
  bool sessionId;
  bool ttl;
  bool allowedClientIpAddresses;
} _StreamControlService_keepStreamSessionAlive_args__isset;

class StreamControlService_keepStreamSessionAlive_args {
 public:

  StreamControlService_keepStreamSessionAlive_args() : sessionId(""), ttl(0) {
  }

  virtual ~StreamControlService_keepStreamSessionAlive_args() throw() {}

  std::string sessionId;
  int64_t ttl;
  std::vector<std::string>  allowedClientIpAddresses;

  _StreamControlService_keepStreamSessionAlive_args__isset __isset;

  void __set_sessionId(const std::string& val) {
    sessionId = val;
  }

  void __set_ttl(const int64_t val) {
    ttl = val;
  }

  void __set_allowedClientIpAddresses(const std::vector<std::string> & val) {
    allowedClientIpAddresses = val;
  }

  bool operator == (const StreamControlService_keepStreamSessionAlive_args & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(ttl == rhs.ttl))
      return false;
    if (!(allowedClientIpAddresses == rhs.allowedClientIpAddresses))
      return false;
    return true;
  }
  bool operator != (const StreamControlService_keepStreamSessionAlive_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamControlService_keepStreamSessionAlive_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StreamControlService_keepStreamSessionAlive_pargs {
 public:


  virtual ~StreamControlService_keepStreamSessionAlive_pargs() throw() {}

  const std::string* sessionId;
  const int64_t* ttl;
  const std::vector<std::string> * allowedClientIpAddresses;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StreamControlService_keepStreamSessionAlive_result__isset {
  _StreamControlService_keepStreamSessionAlive_result__isset() : success(false) {}
  bool success;
} _StreamControlService_keepStreamSessionAlive_result__isset;

class StreamControlService_keepStreamSessionAlive_result {
 public:

  StreamControlService_keepStreamSessionAlive_result() : success(0) {
  }

  virtual ~StreamControlService_keepStreamSessionAlive_result() throw() {}

  bool success;

  _StreamControlService_keepStreamSessionAlive_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const StreamControlService_keepStreamSessionAlive_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StreamControlService_keepStreamSessionAlive_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamControlService_keepStreamSessionAlive_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StreamControlService_keepStreamSessionAlive_presult__isset {
  _StreamControlService_keepStreamSessionAlive_presult__isset() : success(false) {}
  bool success;
} _StreamControlService_keepStreamSessionAlive_presult__isset;

class StreamControlService_keepStreamSessionAlive_presult {
 public:


  virtual ~StreamControlService_keepStreamSessionAlive_presult() throw() {}

  bool* success;

  _StreamControlService_keepStreamSessionAlive_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StreamControlService_endStreamSession_args__isset {
  _StreamControlService_endStreamSession_args__isset() : sessionId(false) {}
  bool sessionId;
} _StreamControlService_endStreamSession_args__isset;

class StreamControlService_endStreamSession_args {
 public:

  StreamControlService_endStreamSession_args() : sessionId("") {
  }

  virtual ~StreamControlService_endStreamSession_args() throw() {}

  std::string sessionId;

  _StreamControlService_endStreamSession_args__isset __isset;

  void __set_sessionId(const std::string& val) {
    sessionId = val;
  }

  bool operator == (const StreamControlService_endStreamSession_args & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    return true;
  }
  bool operator != (const StreamControlService_endStreamSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamControlService_endStreamSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StreamControlService_endStreamSession_pargs {
 public:


  virtual ~StreamControlService_endStreamSession_pargs() throw() {}

  const std::string* sessionId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StreamControlService_endStreamSession_result__isset {
  _StreamControlService_endStreamSession_result__isset() : success(false) {}
  bool success;
} _StreamControlService_endStreamSession_result__isset;

class StreamControlService_endStreamSession_result {
 public:

  StreamControlService_endStreamSession_result() : success(0) {
  }

  virtual ~StreamControlService_endStreamSession_result() throw() {}

  bool success;

  _StreamControlService_endStreamSession_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const StreamControlService_endStreamSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StreamControlService_endStreamSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamControlService_endStreamSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StreamControlService_endStreamSession_presult__isset {
  _StreamControlService_endStreamSession_presult__isset() : success(false) {}
  bool success;
} _StreamControlService_endStreamSession_presult__isset;

class StreamControlService_endStreamSession_presult {
 public:


  virtual ~StreamControlService_endStreamSession_presult() throw() {}

  bool* success;

  _StreamControlService_endStreamSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class StreamControlServiceClient : virtual public StreamControlServiceIf {
 public:
  StreamControlServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  StreamControlServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void beginStreamSession(std::vector<std::string> & _return, const std::string& sessionId, const int64_t ttl, const std::string& type, const std::vector<std::string> & allowedClientIpAddresses, const std::string& deviceId, const std::string& channelId, const std::string& startTimestamp, const std::string& endTimeStamp);
  void send_beginStreamSession(const std::string& sessionId, const int64_t ttl, const std::string& type, const std::vector<std::string> & allowedClientIpAddresses, const std::string& deviceId, const std::string& channelId, const std::string& startTimestamp, const std::string& endTimeStamp);
  void recv_beginStreamSession(std::vector<std::string> & _return);
  bool keepStreamSessionAlive(const std::string& sessionId, const int64_t ttl, const std::vector<std::string> & allowedClientIpAddresses);
  void send_keepStreamSessionAlive(const std::string& sessionId, const int64_t ttl, const std::vector<std::string> & allowedClientIpAddresses);
  bool recv_keepStreamSessionAlive();
  bool endStreamSession(const std::string& sessionId);
  void send_endStreamSession(const std::string& sessionId);
  bool recv_endStreamSession();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class StreamControlServiceProcessor : public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<StreamControlServiceIf> iface_;
  virtual bool process_fn(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (StreamControlServiceProcessor::*)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_beginStreamSession(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_keepStreamSessionAlive(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_endStreamSession(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  StreamControlServiceProcessor(boost::shared_ptr<StreamControlServiceIf> iface) :
    iface_(iface) {
    processMap_["beginStreamSession"] = &StreamControlServiceProcessor::process_beginStreamSession;
    processMap_["keepStreamSessionAlive"] = &StreamControlServiceProcessor::process_keepStreamSessionAlive;
    processMap_["endStreamSession"] = &StreamControlServiceProcessor::process_endStreamSession;
  }

  virtual bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~StreamControlServiceProcessor() {}
};

class StreamControlServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  StreamControlServiceProcessorFactory(const ::boost::shared_ptr< StreamControlServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< StreamControlServiceIfFactory > handlerFactory_;
};

class StreamControlServiceMultiface : virtual public StreamControlServiceIf {
 public:
  StreamControlServiceMultiface(std::vector<boost::shared_ptr<StreamControlServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~StreamControlServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<StreamControlServiceIf> > ifaces_;
  StreamControlServiceMultiface() {}
  void add(boost::shared_ptr<StreamControlServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void beginStreamSession(std::vector<std::string> & _return, const std::string& sessionId, const int64_t ttl, const std::string& type, const std::vector<std::string> & allowedClientIpAddresses, const std::string& deviceId, const std::string& channelId, const std::string& startTimestamp, const std::string& endTimeStamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->beginStreamSession(_return, sessionId, ttl, type, allowedClientIpAddresses, deviceId, channelId, startTimestamp, endTimeStamp);
        return;
      } else {
        ifaces_[i]->beginStreamSession(_return, sessionId, ttl, type, allowedClientIpAddresses, deviceId, channelId, startTimestamp, endTimeStamp);
      }
    }
  }

  bool keepStreamSessionAlive(const std::string& sessionId, const int64_t ttl, const std::vector<std::string> & allowedClientIpAddresses) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->keepStreamSessionAlive(sessionId, ttl, allowedClientIpAddresses);
      } else {
        ifaces_[i]->keepStreamSessionAlive(sessionId, ttl, allowedClientIpAddresses);
      }
    }
  }

  bool endStreamSession(const std::string& sessionId) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->endStreamSession(sessionId);
      } else {
        ifaces_[i]->endStreamSession(sessionId);
      }
    }
  }

};

}}}} // namespace

#endif
